# client-course-work

# Курсовая работа по дисциплине «Базы данных» 
## ПЕРВАЯ ЧАСТЬ.

-  Созданы три таблицы
 Описание таблиц включает использование **(** хотя бы по одному разу **): NOT
NULL, DEFAULT, PRIMARY KEY, CHECK** и **IDENTITY.**

Исходные данные :
```
Договорные поставки деталей
● номер договора;
● код детали;
● единица измерения;
● дата начала поставки;
● дата завершения поставки;
● план поставки (в количестве единиц измерения);

 Учет поставок деталей
● номер склада;
● номер документа о приеме;
● номер договора;
● код покупной детали;
● единица измерения;
● количество покупных деталей;
● дата поступления.

Наличие изделий на складах
● номер склада;
● код изделия(детали);
● единица измерения;
● количество, имеющееся на складе;
● дата последней операции.
```
``` Наличие деталей <–>>   Учет поставок деталей  <<–> Поставки ```

- Описаны две межтабличные связи :
 ``` 
Одна без использования системного каскадного удаления и
обновления. 
```
``` 
Другая с использованием системного каскадного удаления и
обновления (ON DELETE CASCADE ON UPDATE CASCADE).
```
 ```
Cоздана хранимая процедура с выходными параметрами.
```

## ВТОРАЯ ЧАСТЬ.
- Клиентская часть
Приложение должно включать : главную экранную форму ,
визуализирующую таблицы ранее созданной базы данных

- Подключаем базу данных с помощью драйвера **QODBC** к типу данных
**QSqlDatabase.** Для каждой таблицы создаем **QSqlTableModel.** Задаем каждой
модели стратегию хэширования **OnManualSubmit** (Позволяет отменять
изменения - _revert_ и безвозвратно отправить изменения- _submit_ ).

- Реализовать альтернативную форму  с динамическим отображением всех
таблиц в одном **QSqlTableModel.**

- Создать представление **(VIEW)** на сервере **,** которое показывает в виде
одной таблицы данные из трех таблиц **,** соединенных в соответствии с
межтабличными связями межу ними и отобразить ей на отдельной форме**.**

- Отобразить результат выполнения хранимой процедуры в метке **(Label)** на
основной или альтернативной форме**.**

### Задача **1.** 
Сведения о поставках по договорам **,** завершающимся в текущем
году **:** номер склада **;** код детали **;** номер документа о приеме **;** дата
поступления **;** количество **,** поступившее по этому документу **;** номер
договора **;** план поставки **;** дата завершения поставки.

**Решение** с помощью SQL- запроса.

`SELECT r.id_sklad,r.num_doc,r.id_det,r.register_qt,r.date_deliv,
d.plan_qt,d.last_delivFROMRegisterasrINNERJOINDeliveryasdONd.id_det=r.id_detand
d.id_dogv = r.id_dogv WHERE d.last_deliv <'01/01/22`

### Задача **2.** 
Сведения о поставках по договорам **,** завершающимся в текущем
году **:** номер договора **;** код детали **;** план поставки **;** дата завершения
поставки **;** общий план поставки этой детали по всем договорам **,** приоритет
по договорам **–** нумерация по возрастанию даты завершения поставки
данной детали.

  - Для Задачи-2 задания создать SQL- запрос с группировкой или
оконными функциями.

`SELECT DISTINCT d.id_dogv,d.id_det,last_deliv,d.plan_qt,RANK() OVER
(ORDER BY d.last_deliv) as rank, SUM(register_qt) OVER(PARTITION BY d.id_det)as total FROM
Delivery as d, Register as r WHERE d.id_dogv = r.id_dogv and d.last_deliv <'01/01/22'`

### Задача **3.** 
Сведения о наличии деталей на складах **,** такие что **:**
для этой детали имеется договорная поставка **(** из **09** в **)** с планом поставки **>
1000**
и все поступления **(** из **13** б **)** по этой договорной поставке были в количестве
**> 50** каждое.
  - 1) Выражение РА
```
[id_det, id_dogv][plan_qt > 1000](Delivery) - [id_det, id_dogv][register_qt > 50](Register)
```
  - 2) Запрос на языке РИК , решающий данную задачу
```
НАЙТИ {(det.id_det) | det in Details}
(EXISTS (del in Delivery)(del.plan_qt > 1000 & del.id_det = det.id_det) &
(FORALL(r in Register)
(r.id_det = det.id_det & del.id_dogv = r.id_dogv) ->(r.register_qt > 50))
```

  - 3) SQL-запрос с подзапросами

`SELECT id_det,id_sklad,last_op from Details as det WHERE
EXISTS(select del.plan_qt from Delivery as del where del.plan_qt> plan and del.id_det=
det.id_det and NOT EXISTS(select r.register_qt from Register as r wher er.register_qt<=qt
and del.id_dogv = r.id_dogv and r.id_det = det.id_det`
`plan`, `qt` - параметры
